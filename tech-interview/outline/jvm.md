
## 1.jvm类加载机制
虚拟机把class文件加载到内存，并对数据进行校验、转换解析和初始化，形成被虚拟机直接使用的java类型。
* 类型的加载、连接和初始化都是在运行期完成，这种策略令类加载增加性能开销，但是为java应用程序提供高度的灵活性。

1. 加载
2. 连接: 验证，准备，解析
3. 初始化
4. 使用
5. 卸载

### 加载
1. 通过类的全限定名来获取此类的二进制字节流
2. 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

举例：
1. jar, war, ear
2. applet
3. JDKProxy, ProxyGenerator.generateProxyClass --> $Proxy代理类
4. jsp --> servlet class

### 连接
#### 验证
确保Class文件中的字节流包含的信息符合当前虚拟机的规范，不会危害虚拟机自身的安全

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

1. 文件格式验证
* 魔数
* 主次版本号
* 常量池中的常量
* 常量索引是否存在
* 常量中是否有不符合UTF8编码的信息

2. 元数据验证
* 是否有父类
* 是否继承不被允许继承的类（final)
* 类是否实现该实现的方法
* 类中字段、方法的检查

3. 字节码验证
* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
* 保证跳转指令不会跳转到方法体以外的字节码指令上
* 保证方法体中的类型转换是有效的

4. 符号引用验证
* 符号引用中通过字符串描述能否找到对应的类
* 在类中能否找到对应的方法与字段（方法描述符）
* 符号引用中的类，字段，方法是否可以被当前类访问

#### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
类变量而非实例变量，至于初始默认值，则交由类初始化去完成

#### 解析
解析阶段就是虚拟机将常量池中的符号引用替换为直接引用的过程

* 符号引用：符号引用用一组符号来描述引用目标。引用目标不一定已经加载到内存中。
* 直接引用：直接引用可以是直接指向目标的指针、或者间接引用的句柄，引用目标已经加载到内存中。

在anewarray,invoke*,get*等字节码使用前，需要对操作的符号引用进行解析，而常量的符号引用则根据实现有所不同

### 初始化
类初始化阶段是类加载过程的最后一步

* <clinit>()方法是编译器自动收集类中的所有类变量的复制动作和静态语句块的语句合并产生，顺序由语句的定义的顺序决定，
同时子类的<clinit>()方法执行前，需要保证其父类的类初始化方法已经执行完毕。
* 虚拟机内部会正确地对类初始化进行正确的同步，保证每个类的初始化只执行一次。

### 类加载器
类加载器的名称空间，即同一个类加载器下的同一个类是像等价的。

#### 双亲委派模型
启动类加载器与其他类加载器

1. Bootstrap : java \lib下的类
2. Extension : java \lib\ext下的类
3. Application: 负责加载用户类路径上的类库

工作过程： 如果一个类加载器收到类加载请求，他不会自己加载，而是把这个请求委派给父加载器进行完成。

JNDI的SPI拓展使用ThreadContextClassLoader,加载具体细节的代码