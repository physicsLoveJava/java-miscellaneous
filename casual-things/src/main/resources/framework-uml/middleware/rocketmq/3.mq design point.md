
## mq design point

![mq design overview](https://pic3.zhimg.com/37f99e0ea64c2b99b87148ec35a3596b_1200x500.jpg)

* 本质
    * 一次RPC转二次
    * 消息转储
    * 合适投递
* 设计要点
    * RPC通信协议
    * 消息存储方案
    * 消费模型实现
    * 消息各阶段事务
    * 防丢防重
    * 批量、异步，消费性能
* 特点
    * 消费方式push/pull
    * 消息堆积能力
    * 消息重复投递
    * 顺序消息
    
### 应用方面
1. 解耦合 --- 不同系统间事件通知
2. 消息可靠投递、最终一致性 --- 基础，分布式事务，保证数据一致性
3. 错峰流控 --- 消息堆积，解决上下游速度差异
4. 消息广播

### 设计思路

从数据流向来看，从就是生产者到转储中心，然后再到消费者，这里面涉及的有
RPC通信，消息存储方案选型，同时为了保证符合各种消费模型，还需要维持订阅关系之类的，
需要注册中心支持，最后还需要维持消息投递与消息消费的可靠性。

总结起来就是：
1. RPC通信
2. 消息存储
3. 订阅关系，注册中心
4. 消息可靠性，事务

#### RPC通信
本质上RPC通信是将过程或者函数调用在另一个地址空间进行触发，当前大部分的RPC框架都有
服务注册，服务发现，负载均衡，序列化协议，通信协议等。

Thrift/Dubbo

#### 存储子系统

选型方案，文件系统、分布式KV，分布式文件系统、数据库

#### 消费关系

MetaQ的消费关系基本上满足了企业关于消息关系的需求，
集群内保证单条消息被某台机器消费，而广播模式下保证消息被不同的组群消费，这些通过不同的消费组ID来区分。

#### 可靠性
消息投递与消息消费的可靠性，原则都是一个保证事务性，在消息没有成功地被投递或者消费前，都需要进行存储，只有成功后才能清除或状态变化。

#### 重复消息与顺序消息
重复消息在可靠性部分保证的情况下，基本上是必然会出现的，而这个需要业务上做幂等处理，
而顺序消息在全局范围内实现是基本上不可行的，性能太差，也不实现，而局部有序则是完全可行的，
只需要保证生产和消费同分区。

#### push还是pull
两者其实都存在的问题是，不知道对方是什么样的状态，
push模式不知道客户端的消费水平，也就没办法合理地推送消息，而消息一旦失败，则反复的推送，最终导致进入死信队列
pull模式则不知道服务端上的消息量级，按照自己的消费水平进行消费，消费完了，不清楚服务端是否还有消息，可能进入忙等，消息也可能会出现延迟，
MetaQ采用长连接的方式，等待服务端消息的推送，这样一定程度可以减少空拉的频率，但是需要额外地维护长连接的数量。


