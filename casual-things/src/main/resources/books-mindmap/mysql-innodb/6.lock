
## Lock

latch 轻量级锁，锁定时间比较短，可以分为mutex和rwlock，主要用于保证并发线程操作临界资源的正确性

lock的对象是事务，用于锁定数据库中的对象，如表，页，行。可能会发生死锁。

### InnoDB存储引擎中的锁

行级锁：
* 共享锁，允许事务读一行数据
* 排他锁，允许事务删除或更新一行数据

意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

意向锁即为表级别锁：
* 意向共享锁， 事务想要获得一张表中某几行的共享锁
* 意向排他锁，事务想要获得一张表中某几行的排他锁

### 一致性非锁定读（consistent nonblocking read）

InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。
如果读取的行正在执行DELTE或者UPDATE操作，这时读取操作不会因此去等待行上的锁释放，相反地，
Innodb会读取行的一个快照数据。

在事务隔离级别 READ COMMITTED 和 REPEATABLE READ (InnoDB 存储引擎
的默认事务隔离级别） 下， InnoDB 存储引擎使用非锁定的一致性读。 然而， 对于快照数
据的定义却不相同。 在 READ COMMITTED 事务隔离级别下， 对于快照数据， 非一致
性读总是读取被锁定行的最新一份快照数据。 而在 REPEATABLE READ 事务隔离级别
下， 对于快照数据， 非一致性读总是读取事务开始时的行数据版本。


### 一致性锁定读

当数据库需要对读取操作进行加锁保证数据逻辑的一致性的时候，数据要支持加锁语句

select ... for update
select ... lock in share mode

### 自增长与锁

插人操作会依据这个自增长的计数器值加 1 赋予自增长列。 这个实现方式称做
AUTO-INC Locking。 这种锁其实是采用一种特殊的表锁机制， 为了提高插入的性能， 锁
不是在一个事务完成后才释放， 而是在完成对自增长值插入的 SQL 语句后立即释放。

### 外键和锁

在 InnoDB 存储引擎中， 对于一个外键列， 如果没有显式地对这个列加索引， InnoDB 存储引擎自动对其加一
个索引。

### 行锁的算法

* record lock: 单个行记录上的锁
* gap lock: 间隙锁，锁定一个范围，但不包括记录本身
* next-key lock: 上面两个锁的叠加，锁定一个范围，并且锁定记录本身

### innoDB 幻读

read committed: read lock
repeatable read: next-key locking

### 锁问题

read uncommitted: 脏读
read committed: 不可重复读(幻读)
repeatable read: 丢失更新

### 锁升级
锁升级是指将当前锁的粒度降低。主要是因为锁的开销比较大，锁升级会将资源消耗降低，但是同时也降低了并发性







