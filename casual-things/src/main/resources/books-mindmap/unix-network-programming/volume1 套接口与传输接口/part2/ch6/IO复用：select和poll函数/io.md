
## i/o复用：select 和 poll函数

存在的问题：
服务器tcp虽然正确地给客户tcp发送一个FIN，但是客户进程正阻塞与标准输入读，它知道从套接口读时，才能看到此文件结束符（可能已经过了很长时间）。

我们需要这样的能力：如果一个或多个I/O条件满足（例如，输入以准备好被读，或者描述子可以承接更多的输出）时，我们就被通知。（i/o复用）由select和poll支持

应用场合：
1. 客户处理多个描述字时
2. 如果tcp服务器纪要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用
3. 如果一个服务器既要要出tcp,又要处理udp，一般也要使用I/O复用
4. 如果一个服务器要处理多个服务或者多个协议，一般要使用I/O复用

### I/O模型
1. 阻塞I/O
2. 非阻塞I/O
3. I/O复用（select 和 poll)
4. 信号驱动I/O(SIGIO)
5. 异步I/O(aio)

磁盘输入操作的两个不同阶段：
1. 等待数据准备好
2. 从内核到进程拷贝数据

套接字上的输入操作：
1. 等待数据到达网络，当分组到达时，它被拷贝到内核中的某个缓冲区
2. 将数据从内核缓冲区拷贝到应用缓冲区

#### 阻塞IO模型
进程调用recvfrom,此系统调用直到数据报到达并且拷贝至应用缓冲区或者是出错才返回。
1. 等待数据
2. 将数据从内核拷贝到用户空间

#### 非阻塞IO模型
当我们把套接字设置为非阻塞方式时，即通知内核：当请求I/O操作非得让进程睡眠不能完成时，不要让进程睡眠，而应返回一个错误。

当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称此过程为轮询。

1. 进程返回调用recvfrom,等待返回成功
2. 等数据报准备好时，将数据从内核拷贝到用户空间
3. 拷贝完成

#### I/O复用
有了I/O复用，我们就可以调用select或者poll,在这两个系统调用中的某一个上阻塞，而不是阻塞与真正的I/O系统调用。

我们阻塞与select调用，等待数据报套接字可读。当select返回可读条件时，我们调用recvfrom将数据报拷贝至应用缓冲区。
使用select的好处在于我们可以等待多个描述字准备好。

1. select等待多个套接口中的任意一个可读
2. recvfrom，将数据从内核拷贝到用户空间
3. 拷贝完成返回

#### 信号驱动I/O模型
我们可以让内核在描述字准备好时用SIGIO通知我们

1. 注册SIGIO信号处理程序，立刻返回非阻塞
2. 数据报准备好，SIGIO传递信号
3. recvfrom，将数据从内核拷贝到用户空间
4. 拷贝完成返回

#### 异步I/O模型
我们让内核启动操作，并在整个操作完成后（包括将数据从内核拷贝到我们自己的缓冲区）通知我们。
与信号驱动模型的主要区别是：
信号驱动I/O是由内核通知我们合适可以**启动**一个I/O操作，而异步I/O模型是由内核**通知**我们I/O操作何时完成。

1. aio_read 立刻返回
2. 数据准备好，从内核空间拷贝到用户空间，传递给aio_read中的指定信号
3. 程序处理数据报

#### 同步I/O与异步I/O
1. 同步I/O操作引起请求进程阻塞，直到I/O操作完成
2. 异步I/O操作不引起请求进程阻塞

对应前面的：
1. 阻塞I/O
2. 非阻塞I/O
3. I/O复用
4. 信号驱动
同步I/O

异步I/O模型才是异步I/O



