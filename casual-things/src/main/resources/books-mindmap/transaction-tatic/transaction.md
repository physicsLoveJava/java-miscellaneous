
## 事务模型

1. 本地事务模型， 事务由资源管理器管理（数据源提供者、队列连接器）
2. 编程式事务模型，Java事务接口（Java Transaction API, JTA）以及其底层实现来完成事务管理
3. 声明式事务模型，框架管理了事务的提交和回滚，开发者只需要告诉框架回滚的情况和事务的类型


### ACID

### JTA && JTS
java transaction api -- java transaction service
jdbc -- mysql jdbc driver

### 本地事务模型
自动提交设置应该在事务开始前关闭，否则不能保证整体事务的一致性
针对连接而非事务

### 编程事务模型
可以通过begin, commit, rollback等api对事务进行管理，针对事务而非连接

### 声明式事务模型
通过框架管理事务

#### 事务隔离级别
* ReadUncommitted
* ReadCommitted
* RepeatableRead
* Serializable

**ReadUncommitted**
允许事务读取其他事务未提交的对数据库的更改

**ReadCommitted**
允许多个事务对同一份数据进行访问，但是在未提交前对自己的更改进行隐藏，直到提交。

**RepeatableRead**
事务在开始读取都某个数据的值后，在后续的对该数据的查询过程中，都是该值，除非本事务对其进行修改。

**Serializable**
同一个时间点，仅存在单个事务进行访问数据的操作

#### 事务属性
* Required(需要)
* Mandatory(强制必须的)
* RequiresNew(需要新的)
* Supports(支持)
* NotSupported(不支持)
* Never(不用)

**Required**
当前需要事务，如果存在则使用，不存在则创建

**Mandatory**
方法需要事务，如果不存在事务，则抛出异常

**RequiresNew**
方法被调用时，需要开启一个新的事务，当前存在的事务会被挂起，同时当新的事务结束后，被挂起的事务会被继续执行。
考虑日志审计部分的功能

**Supports**
当前方法并不需要事务，当时当调用该方法的上下文中存在事务时，则会使用该事务。
可以通过该属性实现，查询已提交的信息

**NotSupported**
该方法不使用事务，如果当前存在事务，则该事务会暂停直到该方法结束
可以在方法中包含排斥事务的代码

**Never**
当前方法不允许有事务上下文

### 分布式事务 && XA
XA：事务管理器和资源管理器
事务管理器保证事务的提交和回滚，通过底层的API
资源管理器则协调和控制资源，数据库和消息队列等

#### 两段提交（2pc)

第一阶段，所有的资源被轮询，是否准备好提交作业，
准备好（Ready), 只读的（Read-Only)，未准备好（Not-Ready)

第二阶段， 所有参与者准备好，则所有资源进行提交，对于只读资源，则排除掉

若第一阶段存在未准备好的资源，则整个事务进行回滚

#### 经验异常（Heuristic Exception)
事务管理器在第一个阶段对所有的资源进行获取后，在后续的提交阶段，发现某些资源并没有达到要求，这时系统抛出异常。









