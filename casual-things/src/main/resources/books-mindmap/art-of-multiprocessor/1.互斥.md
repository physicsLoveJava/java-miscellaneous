
## 互斥性

互斥、无饥饿（安全性、活跃性）

### LockOne
```java

class LockOne implements Lock {
    private volatile boolean[] flag = new boolean[2];
    
    public void lock() {
        int i = Thread.getId();
        int j = 1 - i;
        flag[i] = true;
        while(flag[j]) {}
    }
    
    public void unlock() {
        int i = Thread.getId();
        flag[i] = false;
    }
}

```

lockOne 算法满足互斥性，但是当两个线程都先于读取到flag变量前，进行flag变量的写操作，则出现死锁问题。

### LockTwo
```java

class LockTwo implements Lock {
    private volatile int victim;
    
    public void lock() {
        int i = Thread.getId();
        victim = i;
        while(victim == i) {}
    }
    
    public void unlock() {}
}

```
lockTwo 算法满足互斥性，但是当一个线程先于另一个线程执行时，会出现死锁问题。


### Peterson算法
```java
class Peterson implements Lock {
    private volatile boolean[] flag = new boolean[2];
    private volatile int victim;
    public void lock() {
        int i = Thread.getId();
        int j = 1 - i;
        flag[i] = true;
        victim = i;
        while(flag[j] && victim == i) {}
    }
    
    public void unlock() {
        int i = Thread.getId();
        flag[i] = false;
    }
}

```

Peterson算法满足互斥性和无饥饿性


